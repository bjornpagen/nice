import * as fs from "node:fs/promises"
import * as path from "node:path"
import * as errors from "@superbuilders/errors"
import { inngest } from "@/inngest/client"
import { qti } from "@/lib/clients"
import { ErrQtiNotFound } from "@/lib/qti"
import { extractIdentifier } from "@/lib/xml-utils"

export const ingestAssessmentItemOne = inngest.createFunction(
	{
		id: "ingest-assessment-item-one",
		name: "Ingest One QTI Assessment Item",
		// Apply concurrency limits to avoid overwhelming the provider.
		concurrency: {
			limit: 200,
			// Serialize writes for the same item to prevent race conditions using provided identifier
			key: "event.data.identifier || null"
		},
		// Define a retry strategy for transient provider errors.
		retries: 3
	},
	{ event: "qti/assessment-item.ingest.one" },
	async ({ event, logger }) => {
		const { courseSlug, identifier } = event.data
		if (!identifier) {
			logger.error("item ingestion: missing identifier")
			// Returning successfully to prevent retries for malformed data.
			return { identifier: null, status: "failed_no_id" }
		}

		logger.info("Ingesting assessment item", { identifier, courseSlug })

		// Load item xml and metadata from disk
		const filePath = path.join(process.cwd(), "data", courseSlug, "qti", "assessmentItems.json")
		const readResult = await errors.try(fs.readFile(filePath, "utf-8"))
		if (readResult.error) {
			logger.error("file read", { file: filePath, error: readResult.error })
			throw errors.wrap(readResult.error, "file read")
		}
		// biome-ignore lint: Type assertion needed for loading raw data generated by QTI Generation flow
		const items = JSON.parse(readResult.data) as Array<{ xml: string; metadata?: Record<string, unknown> }>
		const match = items.find((it) => extractIdentifier(it.xml, "qti-assessment-item") === identifier)
		if (!match) {
			logger.error("item xml not found on disk", { identifier, file: filePath })
			throw errors.new("item xml missing")
		}
		const payload = { identifier, xml: match.xml, metadata: match.metadata }

		// Upsert logic: attempt to update, and if it's not found, create it.
		const updateResult = await errors.try(qti.updateAssessmentItem(payload))

		if (updateResult.error) {
			if (errors.is(updateResult.error, ErrQtiNotFound)) {
				logger.info("Item not found, creating new.", { identifier })
				const createResult = await errors.try(qti.createAssessmentItem(payload))
				if (createResult.error) {
					logger.error("Failed to create assessment item after 404 on update.", {
						identifier,
						error: createResult.error
					})
					throw createResult.error // Throw to trigger Inngest retry.
				}
				logger.info("Successfully created assessment item.", { identifier })
				return { identifier, status: "created" }
			}
			// For other errors (e.g., 5xx), throw to trigger Inngest retry.
			logger.error("Failed to update assessment item.", { identifier, error: updateResult.error })
			throw updateResult.error
		}

		logger.info("Successfully updated assessment item.", { identifier })
		return { identifier, status: "updated" }
	}
)
