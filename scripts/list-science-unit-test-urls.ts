#!/usr/bin/env bun
import * as fs from "node:fs/promises"
import * as path from "node:path"
import * as errors from "@superbuilders/errors"
import * as logger from "@superbuilders/slog"
import { and, eq, inArray } from "drizzle-orm"

import { db } from "@/db"
import * as schema from "@/db/schemas"
import { HARDCODED_SCIENCE_COURSE_IDS } from "@/lib/constants/course-mapping"

// Configuration
const OUTPUT_DIR = path.join(process.cwd(), "export")
const OUTPUT_FILE = path.join(OUTPUT_DIR, "science-unit-test-urls.md")
const BASE_URL = "https://qti.alpha-1edtech.com/api/assessment-tests/nice_"

async function ensureOutputDir(): Promise<void> {
	const mkdirResult = await errors.try(fs.mkdir(OUTPUT_DIR, { recursive: true }))
	if (mkdirResult.error) {
		logger.error("failed to create export directory", { error: mkdirResult.error, dir: OUTPUT_DIR })
		throw errors.wrap(mkdirResult.error, "directory creation")
	}
}

async function fetchUnitTestIdsForCourses(courseIds: readonly string[]): Promise<string[]> {
	// Get units for the given course IDs
	const unitsResult = await errors.try(
		db
			.select({ id: schema.niceUnits.id })
			.from(schema.niceUnits)
			.where(inArray(schema.niceUnits.courseId, courseIds))
			.prepare("scripts_list_science_unit_test_urls_get_units")
			.execute()
	)
	if (unitsResult.error) {
		logger.error("failed to fetch units for courses", { error: unitsResult.error, courseIds })
		throw errors.wrap(unitsResult.error, "database query for units")
	}

	const unitIds = unitsResult.data.map((u) => u.id)
	if (unitIds.length === 0) return []

	// Get UnitTest assessments whose parent is a Unit and parentId in unitIds
	const assessmentsResult = await errors.try(
		db
			.select({ id: schema.niceAssessments.id })
			.from(schema.niceAssessments)
			.where(
				and(
					eq(schema.niceAssessments.parentType, "Unit"),
					inArray(schema.niceAssessments.parentId, unitIds),
					eq(schema.niceAssessments.type, "UnitTest")
				)
			)
			.prepare("scripts_list_science_unit_test_urls_get_assessments")
			.execute()
	)
	if (assessmentsResult.error) {
		logger.error("failed to fetch unit test assessments", { error: assessmentsResult.error })
		throw errors.wrap(assessmentsResult.error, "database query for assessments")
	}

	return assessmentsResult.data.map((a) => a.id)
}

async function writeMarkdown(urls: string[]): Promise<void> {
	const lines: string[] = [
		"# Science Unit Test URLs",
		"",
		"The following URLs are generated by appending the unit test ID to the base endpoint:",
		`Base: ${BASE_URL}`,
		"",
		...urls.map((id) => `- ${BASE_URL}${id}/questions`)
	]
	const content = `${lines.join("\n")}\n`

	const writeResult = await errors.try(fs.writeFile(OUTPUT_FILE, content, "utf-8"))
	if (writeResult.error) {
		logger.error("failed to write markdown output", { error: writeResult.error, file: OUTPUT_FILE })
		throw errors.wrap(writeResult.error, "file write")
	}
}

async function main(): Promise<void> {
	logger.info("starting science unit test URL generation")

	await ensureOutputDir()

	// The mapping file guarantees 6 science course IDs
	const courseIds = [...HARDCODED_SCIENCE_COURSE_IDS]
	logger.debug("using hardcoded science course ids", { count: courseIds.length, courseIds })

	const unitTestIds = await fetchUnitTestIdsForCourses(courseIds)
	logger.info("fetched unit test assessments", { count: unitTestIds.length })

	// Ensure uniqueness and stable ordering
	const uniqueIds = Array.from(new Set(unitTestIds)).sort()

	await writeMarkdown(uniqueIds)

	logger.info("science unit test URL generation completed", { output: OUTPUT_FILE, count: uniqueIds.length })
}

const result = await errors.try(main())
if (result.error) {
	logger.error("script failed", { error: result.error })
	process.exit(1)
}
